A research project aiming at developing a [digital scientific notation](Digital%20scientific%20notation.md) for computational physics and chemistry. Such a notation should be suitable as well for other domains using predominantly mathematical models, but my focus is on the domains that I know best.

Leibniz is named after
[Gottfried Wilhelm Leibniz](https://en.wikipedia.org/wiki/Gottfried_Wilhelm_Leibniz),
who made important contributions to science, mathematics, formal
logic, and computation, topics that are all relevant to this project.
He invented a widely used [notation for calculus](https://en.wikipedia.org/wiki/Leibniz%27s_notation),
laid the foundation of equational logic by his [definition of equality](https://en.wikipedia.org/wiki/Equality_(mathematics)),
and anticipated formal logic with his ["calculus ratiocinator"](https://en.wikipedia.org/wiki/Calculus_ratiocinator).

## An embeddable specification language

A [first iteration of Leibniz](https://github.com/khinsen/leibniz) focused on developing a [formal language](Formal%20language.md) for embedding [specifications](Specification.md) and algorithms into a narrative written principally for human readers. It is the subject of a [publication](https://doi.org/10.7717/peerj-cs.158) and of a (recorded) [presentation](https://youtu.be/YbznItQpALo?t=2104) at [RacketCon 2020](https://con.racket-lang.org/2020/). The latter is the best introduction to Leibniz at this time. You can then move on to studying a [pedagogical example](https://khinsen.net/leibniz-examples/examples/leibniz-by-example.html) and other, more technical [examples](https://khinsen.net/leibniz-examples/).

The focus on a formal language embeddable into a narrative motivated the choice of the [Racket](https://racket-lang.org/) ecosystem and in particular its documentation language [Scribble](https://docs.racket-lang.org/scribble/). Leibniz is implemented as an extension to Scribble. It is an algebraic [specification language](https://en.wikipedia.org/wiki/Specification_language), based on [equational logic](https://en.wikipedia.org/wiki/Equational_logic) and [term rewriting](https://en.wikipedia.org/wiki/Rewriting#Term_rewriting_systems). Its design is strongly inspired by [Maude](https://maude.cs.illinois.edu/w/index.php/The_Maude_System) and its predecessors from the [OBJ family](https://cseweb.ucsd.edu/~goguen/sys/obj.html). The first iteration of Leibniz is in fact equivalent to a subset of Maude (providing only Maude's *functional modules*), but with a very different syntax in view of its intended use. A nice feature of algebraic specifications is that they consist of small elements whose order rarely matters. This makes it easier to insert these elements into the flow of a narrative, much like mathematical notation.

The goal I have set myself for a usable version of Leibniz is the possibility to write a readable specification for a [molecular mechanics](Molecular%20mechanics.md) [force field](Force%20field.md) such as the [AMBER family](https://ambermd.org/AmberModels.php). The first iteration is clearly not good enough for that. Most of all, it lacks built-in support for collections, such as "all atoms in a molecule". You can define collections such as lists explicitly, of course, as it is done in Maude. Another mathematical concept that is not easy to represent in Maude or Leibniz 1 is the function. Maude is an intentionally minimalistic language, which I think a digital scientific notation should not be.  This sets the agenda for the next iteration: improving expressiveness.

## An interactive authoring system

At this stage of the project, the edit-compile-run/view cycle of Racket and Scribble became more and more cumbersome. Modifying and debugging both the implementation of a new language and test code written in this language at the same time led to feedback loop of unacceptable duration. I had just discovered, through fortuitous circumstances, the [Pharo](Pharo.md) live [programming system](Programming%20system.md), which is a descendant of [Smalltalk](Smalltalk.md). Implementing the [second iteration of Leibniz](https://github.com/khinsen/leibniz-pharo) in Pharo looked like a good opportunity to evaluate live programming in general, and Pharo in particular, for a project that could benefit a lot from this improved interactivity.

Shortly after starting the second iteration, [Glamorous Toolkit](Glamorous%20Toolkit), a new user interface and development environment for Pharo focusing on [moldable development](Moldable%20development.md) was made available for adventurous explorers (it has by now advanced to beta status). I rapidly adopted it for my work on Leibniz (and other projects), because moldable development turned out to be a very good fit for my work. Another major step was the introduction of [Lepiter](https://lepiter.io/feenk/introducing-lepiter--knowledge-management--e2p6apqsz5npq7m4xte0kkywn/), a computational notebook on steroids integrated into Glamorous Toolkit. It turned the implementation of an interactive authoring system for Leibniz from a over-ambitious idea into something that looks doable. This became the second goal of the second iteration of Leibniz, but has not yet been tackled for real.

There has been significant progress on the first goal. The simple sort labels of Maude and Leibniz 1 have given way to sort terms, allowing the declaration of sorts such as "a list of 3 positive integers". An implementation of multidimensional arrays on this basis is currently in progress.

Another promising discovery that became an experimental feature of Leibniz is [e-graphs](https://en.wikipedia.org/wiki/E-graph) and their use in [equality saturation](https://blog.sigplan.org/2021/04/06/equality-saturation-with-egg/), inspired by the [Metatheory](https://docs.juliahub.com/Metatheory/Hi8Kc/0.3.2/egraphs/) package for [Julia](Julia.md).
